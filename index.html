<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-数字签名" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T03:00:42.272Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名满足下面条件<br>认证性（Authenticity）：验证消息确实是由声称的发送者发送的，不是伪造的<br>完整性（Integrity）：验证消息在传输或存储过程中没有被篡改<br>不可否认性（Non-repudiation）：发送者之后不能否认他发送过这条消息（因为签名只有他本人能生成）</p>
<p>总体来说数字签名是公钥密码的逆用，使用私钥签名，使用公钥验签<br>数字签名方案的三个部分：<br>（1）密钥生成：生成签名者所需的公私钥对；<br>（2）签名过程：对于m，利用私钥进行签名s &#x3D; S(m)， 输出(m, s)；<br>（3）验证过程：验证者使用公钥验证签名，如果验证方程成立，则承认该签名；否则拒绝。</p>
<h1 id="RSA-签名"><a href="#RSA-签名" class="headerlink" title="RSA 签名"></a>RSA 签名</h1><h2 id="签密方案"><a href="#签密方案" class="headerlink" title="签密方案"></a>签密方案</h2><p>A向B传递加密的消息-签名对<br>$C &#x3D; (M^{d_A} mod n_A)^{e_B} mod n_B$<br>$M’ &#x3D; M^{e_B} mod n_B$<br>B解密和验签<br>$C^{d_B} &#x3D; M^{d_A} &#x3D; S_A$<br>$(M’)^{d_B} mod n_B &#x3D;M$<br>$S_A^{e_A} &#x3D; (M^{d_A})^{e_A} &#x3D; M mod n_A$</p>
<h2 id="简化计算的性质"><a href="#简化计算的性质" class="headerlink" title="简化计算的性质"></a>简化计算的性质</h2><p>如果 $ t &#x3D; LCM[p - 1, q - 1] $ （最小公倍数），并且 $ k \equiv r \mod t $ 且 $ k &gt; r $，那么 $ a^k \equiv a^r \mod pq $<br>因为 $ a^k \equiv a^r \mod p $ 且 $a^k \equiv a^r \mod q$<br>根据中国剩余定理，我们可以得出$a^k \equiv a^r \mod pq$</p>
<p>消息过大时对消息先用哈希函数处理</p>
<h1 id="ELGamal数字签名"><a href="#ELGamal数字签名" class="headerlink" title="ELGamal数字签名"></a>ELGamal数字签名</h1><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>大素数$P$，乘法群$Z_p^*$的生成元$g$<br>随机数$x$,$x&lt;p-2$<br>$y &#x3D; g^xmodp$<br>公钥为$(p,g,y)$私钥为$x$</p>
<h2 id="签名过程"><a href="#签名过程" class="headerlink" title="签名过程"></a>签名过程</h2><p>$gcd(k,p-1)&#x3D; 1,k\in Z_{p-1}$<br>$s(m) &#x3D; (s_1,s_2) \in Z_p^* \times Z_{p-1}$<br>$s_1 &#x3D; g^kmod p$<br>$s_2 &#x3D; (m-xs_1)k^{-1}mod(p-1)$</p>
<h2 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h2><p>$y^{s_1}s_1^{s_2} &#x3D; g^m modp$<br>上式成立时则签名为有效签名</p>
<h1 id="Schnorr签名方案"><a href="#Schnorr签名方案" class="headerlink" title="Schnorr签名方案"></a>Schnorr签名方案</h1><h2 id="密钥生成-1"><a href="#密钥生成-1" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>选择一个大素数 $p$ 和素数 $q$ ,$q|(p-1)$<br>选择阶为q子群生成元 $g$<br>$g &#x3D; a^{(p-1)&#x2F;q}modp$若$g&#x3D;1$则重试<br>私钥：随机选择一个整数 $x (1 &lt; x &lt; q)$<br>公钥：计算 $y &#x3D; g^x mod p,(p,q,g,y)$</p>
<h2 id="签名生成"><a href="#签名生成" class="headerlink" title="签名生成"></a>签名生成</h2><p>选择一个随机数 $k (1 &lt; k &lt; q)$<br>计算 $r &#x3D; g^k mod p$<br>计算 $e &#x3D; H(r || m)$，其中 $H$ 是一个哈希函数，$||$ 表示连接。$e$ 是一个挑战值。<br>计算 $S &#x3D; k + x * e mod q$<br>签名是 $(e, S)$</p>
<h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>获取公钥 $y$、消息 $m$ 和签名 $(e, S)$<br>计算 $u &#x3D; g^S * y^{-e} mod p$<br>计算 $e’ &#x3D; H(u || m)$<br>如果 $e &#x3D;&#x3D; e’$，则验证通过，签名有效；否则无效。</p>
<h1 id="数字签名标准-DSS"><a href="#数字签名标准-DSS" class="headerlink" title="数字签名标准 DSS"></a>数字签名标准 DSS</h1><h2 id="密钥生成-2"><a href="#密钥生成-2" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>选择公共参数 $p, q, g$<br>用户选择私钥 $x$（一个小于 $q$ 的随机数）。<br>计算公钥 $y &#x3D; g^x mod p$</p>
<h2 id="签名生成-1"><a href="#签名生成-1" class="headerlink" title="签名生成"></a>签名生成</h2><p>选择一个随机数 $k$<br>计算消息的哈希值 $H(m)$<br>计算 $r ( (g^k mod p) mod q )$。如果 $r&#x3D;0$，重新选择 $k$。<br>计算 $s ( k^(-1) * (H(m) + x*r) ) mod q$。如果 $s&#x3D;0$，重新选择 $k$。<br>签名是 $(r, s)$。</p>
<h2 id="签名验证-1"><a href="#签名验证-1" class="headerlink" title="签名验证"></a>签名验证</h2><p>获取公钥 $y$、消息 $m$ 和签名 $(r, s)$。<br>检查 $r$ 和 $s$ 是否在 $1$ 到 $q-1$ 之间。如果不是，签名无效。<br>计算消息的哈希值 $H(m)$。<br>计算 $w s^(-1) mod q$<br>计算 $u1 (H(m) * w) mod q$<br>计算 $u2 (r * w) mod q$<br>计算 $v ( (g^u1 * y^u2) mod p ) mod q$<br>如果 $v &#x3D; r$，则签名有效；否则无效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" data-id="cmfajc26s0002hkf04yia7g2l" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-分组密码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T02:59:17.823Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分组密码概述"><a href="#分组密码概述" class="headerlink" title="分组密码概述"></a>分组密码概述</h1><h2 id="扩散与混淆"><a href="#扩散与混淆" class="headerlink" title="扩散与混淆"></a>扩散与混淆</h2><p>克服统计分析，采用扩散和混淆两基本方式<br>扩散：就是使明文的每一位影响密文中的许多位，<br>这样可以隐蔽明文的统计特性。<br>混淆：密文的每一位受密钥尽可能多位的影响。<br>使密文和密钥关系复杂，从而统计分析更加困难。<br>换位变换(置换&#x2F;permutation)可以实现有效的扩散。<br>代替变换(substitution)可以达到比较好的混淆</p>
<details>
<summary>P置换</summary>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">permutation</span>(<span class="params">data, permutation_table</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行P置换</span></span><br><span class="line"><span class="string">    param data: 输入数据，列表或元组</span></span><br><span class="line"><span class="string">    param permutation_table: 置换表</span></span><br><span class="line"><span class="string">    return: 置换后的数据</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> [data[i] <span class="keyword">for</span> i <span class="keyword">in</span> permutation_table]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inverse_permutation</span>(<span class="params">permutation_table</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算逆P置换表</span></span><br><span class="line"><span class="string">    param permutation_table: 原始置换表</span></span><br><span class="line"><span class="string">    return: 逆置换表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inverse_table = [<span class="number">0</span>] * <span class="built_in">len</span>(permutation_table)</span><br><span class="line">    <span class="keyword">for</span> i, pos <span class="keyword">in</span> <span class="built_in">enumerate</span>(permutation_table):</span><br><span class="line">        inverse_table[pos] = i</span><br><span class="line">    <span class="keyword">return</span> inverse_table</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h2 id="分组密码的结构"><a href="#分组密码的结构" class="headerlink" title="分组密码的结构"></a>分组密码的结构</h2><p>Feistel结构<br>每轮处理一半明文，加解密算法相同，代表为DES<br>SPN结构<br>每轮处理整个明文分组，加解密算法不同，代表为AES</p>
<h2 id="分组密码的优劣"><a href="#分组密码的优劣" class="headerlink" title="分组密码的优劣"></a>分组密码的优劣</h2><p>分组密码： 密钥生成简单，同时处理一组明文段，<br>加密过程复杂， 密钥长度固定。<br>序列密码： 产生（伪）随机的密钥流，每次处理一个明文字母。 加密过程简单，需要明文与密钥同步。<br>分组密码适用性更广，易于标准化；<br>序列密码速度更快，可实时通信</p>
<h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>明文分组： 64 bit<br>密文分组： 64 bit<br>密钥： 64 bit，其中8bit为校验位，实际 56 bit<br>轮数： 16 轮<br>加密函数： 8个 6-4 S盒；P置换。<br>整体结构： Feistel<br>关于Feistel结构<br>参考小规模DES实验<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luminescence/p/18904923">https://www.cnblogs.com/luminescence/p/18904923</a></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luminescence/p/18866999">https://www.cnblogs.com/luminescence/p/18866999</a></p>
<h2 id="DES的特点"><a href="#DES的特点" class="headerlink" title="DES的特点"></a>DES的特点</h2><p>除密钥顺序之外，加密和解密步骤完全相同；<br>诟病：密钥太短，迭代次数可能太少，<br> S盒可能存在不安全隐患。</p>
<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><p>差分分析：一种选择明文攻击，通过分析明文对的差值，对密文对的差值的影响来恢复某些密钥比特。<br>穷举攻击：人们利用网络并行计算可以在20多小时，破译56位的DES。DES已变得不安全了。<br>线性分析：一种已知明文攻击，它试图建立起明文、密文和密钥的一组近似线性方程</p>
<h2 id="多重DES"><a href="#多重DES" class="headerlink" title="多重DES"></a>多重DES</h2><p>为了提高安全性，防止穷举攻击，DES还有多重形式。</p>
<h3 id="双重DES"><a href="#双重DES" class="headerlink" title="双重DES"></a>双重DES</h3><p>$c &#x3D; DES_{k_2}(DES_{k_1}(m))$<br>$m &#x3D; DES^{-1}<em>{k_1}(DES^{-1}</em>{k_2}(c))$<br>中间相遇攻击<br>$c&#x3D;c &#x3D; DES_{k_2}(DES_{k_1}(m))$<br>$DES^{-1}<em>{k_2}(c)&#x3D;DES</em>{k_1}(m)$<br>总计算量 $2*2^{56}$</p>
<h3 id="三重DES"><a href="#三重DES" class="headerlink" title="三重DES"></a>三重DES</h3><p>$c &#x3D; DES_{k_3}(DES_{k_2}^{-1}(DES_{k_1}(m)))$<br>$m &#x3D; DES^{-1}<em>{k_1}(DES</em>{k_2}(DES^{-1}_{k_3}(c)))$<br>中间一层用解密形式是为了可以利用三重DES对单重DES加密的密文进行解密</p>
<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>明文分组： 128 bit<br>密文分组： 128 bit<br>密钥： 128、192、256 bit<br>轮数： 10、12、14 轮（圈）<br>加密函数： 8-8的S盒、P（行移位、列混合）<br>密钥生成： 扩展、递归<br>总体结构： SP结构</p>
<p>AES是面向字节的算法：字节为最小单位进行处理。<br>输入明文分组：128bit&#x3D;16×8bit＝16个字节，<br>排成 4×4 的字节数组，称为状态矩阵（State Matrix）<br>轮函数就是对这个数组进行变换</p>
<h2 id="AES中的运算"><a href="#AES中的运算" class="headerlink" title="AES中的运算"></a>AES中的运算</h2><p>AES是面向字节的算法，最小单位是字节(Byte)。<br>一个字节可用二位十六进制数表示，前加0x表示十六进制</p>
<h3 id="字节运算"><a href="#字节运算" class="headerlink" title="字节运算"></a>字节运算</h3><p>一个8比特字节，可以看作$GF(2^8)$域中一个元素<br>AES中用多项式表示<br>$b_7b_6b_5b_4b_3b_2b_1b_0$<br>$b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x+b_0$<br>加法就是多项式对应项相加，系数模二加<br>减法，就是加上减法逆（就是本身）<br>乘法，要模一个8次既约多项式$m(x)$<br>$m(x)&#x3D;x^8+x^4+x^3+x+1$</p>
<p>每一项多次乘x转化为重复使用xtime( )运算。<br>复杂运算化简为简单运算的迭代。<br>$𝐺𝐹(2^8)$上的$xtime( )$算法：<br>(1) 如果$b_7&#x3D;0$则xtime( )运算就是左移一位后补零；<br>(2) 如果$b_7&#x3D;1$,则xtime( )左移一位后补零再异或0x1b。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xtime</span>(<span class="params">byte</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    实现GF(2⁸)上的xtime运算</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> byte &amp; <span class="number">0x80</span>:</span><br><span class="line">        <span class="keyword">return</span> ((byte &lt;&lt; <span class="number">1</span>) ^ <span class="number">0x1B</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> (byte &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gf256_multiply</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在GF(2⁸)上计算两个字节的乘法</span></span><br><span class="line"><span class="string">    xtime分解</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    temp = a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> (b &gt;&gt; i) &amp; <span class="number">1</span>:</span><br><span class="line">            result ^= temp</span><br><span class="line">        temp = xtime(temp)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_hex_input</span>(<span class="params">prompt</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        s = <span class="built_in">input</span>(prompt).strip().upper()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">1</span> <span class="keyword">and</span> s <span class="keyword">in</span> <span class="string">&quot;123456789ABCDEF&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(s, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(s) == <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">all</span>(c <span class="keyword">in</span> <span class="string">&quot;0123456789ABCDEF&quot;</span> <span class="keyword">for</span> c <span class="keyword">in</span> s):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">int</span>(s, <span class="number">16</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;输入无效&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stdhex</span>(<span class="params">temp</span>):</span><br><span class="line">    tempstr = <span class="built_in">str</span>(<span class="built_in">hex</span>(temp))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tempstr) == <span class="number">3</span>:</span><br><span class="line">        tempstr = <span class="string">&#x27;0x0&#x27;</span> + tempstr[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> tempstr</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        a = parse_hex_input(<span class="string">&quot;第一个字节: &quot;</span>)</span><br><span class="line">        b = parse_hex_input(<span class="string">&quot;第二个字节: &quot;</span>)</span><br><span class="line">        result = gf256_multiply(a, b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;结果: <span class="subst">&#123;stdhex(a)&#125;</span> * <span class="subst">&#123;stdhex(b)&#125;</span> = <span class="subst">&#123;stdhex(result)&#125;</span> (十进制: <span class="subst">&#123;result&#125;</span>)\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>除法，也就乘以除数的乘法逆。<br>一般地，可以利用多项式的扩展欧几里得算法求乘法逆。<br>求a(x)关于不可约多项式m(x)的乘法逆。<br>根据扩展欧几里得算法，a(x)和m(x)可表示为<br>$a(x)b(x) + c(c)m(x) &#x3D; 1$<br>$a(x)b(x) &#x3D; 1mod(m(x))$<br>$a(x)^{-1} &#x3D; b(x)mod(m(x))$</p>
<p>S盒构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A=[</span><br><span class="line">    [1 1 1 1 1 0 0 0]</span><br><span class="line">    [0 1 1 1 1 1 0 0]</span><br><span class="line">    [0 0 1 1 1 1 1 0]</span><br><span class="line">    [0 0 0 1 1 1 1 1]</span><br><span class="line">    [1 0 0 0 1 1 1 1]</span><br><span class="line">    [1 1 0 0 0 1 1 1]</span><br><span class="line">    [1 1 1 0 0 0 1 1]</span><br><span class="line">    [1 1 1 1 0 0 0 1]</span><br><span class="line">    ]</span><br><span class="line">C = (1, 1, 0, 0, 0, 1, 1, 0)</span><br></pre></td></tr></table></figure>
<p>s &#x3D; A * b⁻¹ + c</p>
<h3 id="字节替代例题"><a href="#字节替代例题" class="headerlink" title="字节替代例题"></a>字节替代例题</h3><p><img src="https://img2024.cnblogs.com/blog/3567579/202506/3567579-20250622105112517-1819026246.png" alt="image"><br><img src="https://img2024.cnblogs.com/blog/3567579/202506/3567579-20250622105145244-700928516.png" alt="image"></p>
<h3 id="字运算"><a href="#字运算" class="headerlink" title="字运算"></a>字运算</h3><p>一个四字节的字可以看作$GF(2^32)&#x3D;GF((2^8)^4)$中的元素<br>$a_3a_2a_1a_0$<br>用多项式表示<br>$a_x^3+a_2x^2+a_1x+a_0$<br>加法为对应系数相加，逐位模二加<br>乘法为多项式相乘后，模一个四次多项式<br>$M(x) &#x3D; {01}x^4 + {01}$<br>$x^4 + 1&#x3D;(x^2+1)^2$</p>
<p>$d(x)&#x3D;d_{3} x^{3}+d_{2} x^{2}+d_{1} x+d_0$<br>$&#x3D;c_{3} x^{3}+\left(c_{2}-c_{6}\right) x^{2}+\left(c_{1}-c_{5}\right) x+\left(c_{0}-c_{4}\right)$<br>$d_0&#x3D;a_0 \cdot b_0 \oplus a_3 \cdot b_1 \oplus a_2 \cdot b_2 \oplus a_1 \cdot b_3$<br>$d_1&#x3D;a_1 \cdot b_0 \oplus a_0 \cdot b_1 \oplus a_3 \cdot b_2 \oplus a_2 \cdot b_3$<br>$d_2&#x3D;a_2 \cdot b_0 \oplus a_1 \cdot b_1 \oplus a_0 \cdot b_2 \oplus a_3 \cdot b_3$<br>$d_3&#x3D;a_3 \cdot b_0 \oplus a_2 \cdot b_1 \oplus a_1 \cdot b_2 \oplus a_0 \cdot b_3$<br>$\begin{bmatrix}<br>    d_0 \<br>    d_1 \<br>    d_2 \<br>    d_3<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>    a_0 &amp; a_3 &amp; a_2 &amp; a_1 \<br>    a_1 &amp; a_0 &amp; a_3 &amp; a_2 \<br>    a_2 &amp; a_1 &amp; a_0 &amp; a_3 \<br>    a_3 &amp; a_2 &amp; a_1 &amp; a_0<br>\end{bmatrix}\begin{bmatrix}<br>    b_0 \<br>    b_1 \<br>    b_2 \<br>    b_3<br>\end{bmatrix}$  </p>
<h3 id="AES的列混合"><a href="#AES的列混合" class="headerlink" title="AES的列混合"></a>AES的列混合</h3><p>$\begin{bmatrix}<br>    d_0 \<br>    d_1 \<br>    d_2 \<br>    d_3<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>    02 &amp; 03 &amp; 01 &amp; 01 \<br>    01 &amp; 02 &amp; 03 &amp; 01 \<br>    01 &amp; 01 &amp; 02 &amp; 03 \<br>    03 &amp; 01 &amp; 01 &amp; 02<br>\end{bmatrix}\begin{bmatrix}<br>    b_0 \<br>    b_1 \<br>    b_2 \<br>    b_3<br>\end{bmatrix}$<br>列混合前后，两个矩阵各列上所有元素和是对应相等的</p>
<h2 id="AES的特点"><a href="#AES的特点" class="headerlink" title="AES的特点"></a>AES的特点</h2><p>结构简单，适应性强<br>加解密算法不同，解密使用加密的逆模块</p>
<h1 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h1><h2 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h2><p>电码本模式 electronic codebook<br>直接分组，相同明文产生相同密文</p>
<h2 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h2><p>密码分组链接模式 Cipher-Block Chaining<br>使用初始向量与分组1异或，加密后密文1与分组2异或，以此类推<br>缺点：存在错误扩散<br>若在信道上传送的第i组密文ci出现1bit错误，则在解密时，将引起第i组明文mi全错及第i+1组明文mi+1出现1bit错误；此外，第j(j&gt;i+1)组明文$m_j$将不再受此错误影响，系统会自动恢复正常</p>
<h2 id="CFB"><a href="#CFB" class="headerlink" title="CFB"></a>CFB</h2><p>密码反馈模式 Cipher FeedBack<br>使用移位寄存器产生序列，经过分组密码加密后序列与明文分组异或，使用密文分组生成新序列<br>可以不按固定位数加密<br>假设明文分组为j位，首先用初始向量进行操作在移位寄存器得到64位，加密后序列1与明文1异或，得到密文1，丢弃后面$64-j$位并填入移位寄存器生成序列2，以此类推<br>该模式的特点：<br>存在有限的(其实是$[64&#x2F;j]+1$组)错误扩散：当传输的密文组$c_i$出现1bit错误时，解密的明文组$m_i$也有1bit错误，而且随后解密出来的$[64&#x2F;j]$组明文$m_{i+1},m_{i+2},……,m_{i+[64&#x2F;j]}$全错，直至此后原$c_i$的1bit错误刚好移出64级移位寄存器，系统可自动恢复正常。<br>CFB模式给出的是典型的自同步序列密码：只要接收方连续收到$[64&#x2F;j]$组正确的密文，收发双方的64级移位寄存器存储的数据就完全一样，从而双方可重新建立起同步。</p>
<h2 id="OFB"><a href="#OFB" class="headerlink" title="OFB"></a>OFB</h2><p>输出反馈模式 Output FeedBack<br>与CFB类似，但下一个移位寄存器直接使用上一个序列的前j位生成新序列<br>明文分组直接和序列异或后输出密文分组</p>
<h2 id="计数器模式"><a href="#计数器模式" class="headerlink" title="计数器模式"></a>计数器模式</h2><p>使用时间戳做生成序列，经过加密后与明文分组异或得到密文分组</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/" data-id="cmfajc26o0001hkf0g00d8x3n" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-序列密码学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T02:57:44.375Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="序列密码概述"><a href="#序列密码概述" class="headerlink" title="序列密码概述"></a>序列密码概述</h1><p>仿照一次一密<br>将明文编为比特串<br>产生与明文长度相同的密钥流<br>加密与解密均为密钥与比特流异或<br>序列密码的主要任务：设计安全的伪随机密钥产生器</p>
<p>序列密码优缺点<br>处理速度快，实时性好<br>适用于军事、外交等保密系统<br>适应性差，需要密钥同步</p>
<h2 id="线性反馈移位寄存器"><a href="#线性反馈移位寄存器" class="headerlink" title="线性反馈移位寄存器"></a>线性反馈移位寄存器</h2><p>一个$q$元域 $GF(q)$上的 $n$ 阶反馈移位寄存器：<br>$n$ 个寄存器 + 一个反馈函数<br>最左端寄存器为第1级寄存器，最右端为第n级寄存器<br>反馈函数<br>$f(x_1,\dots ,x_n):GF(q)^n \to GF(q)$<br>具有周期状态</p>
<h1 id="LFSR"><a href="#LFSR" class="headerlink" title="LFSR"></a>LFSR</h1><p>$f(x_1,\dots ,x_n) &#x3D; \sum c_nx_1 + \dots +c_1x_n$<br>$[c_1,c_2,\dots ,c_n]$称为结构常数<br>第$i$阶寄存器的结构常数为$n+1-i$</p>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>将此刻状态计算反馈值<br>状态左移移位，输出首位，后补反馈值，形成新状态<br>重复形成周期</p>
<p>输出序列即为一个周期内状态的首位值的序列<br>$\tilde{a} &#x3D; a^{\infty } &#x3D; a_0a_1a_2\dots a_{n-1}a_n$</p>
<p>结论：</p>
<ol>
<li>n-LFSR的结构由其结构常数唯一确定</li>
<li>n-LFSR的结构常数与反馈函数互相唯一确定</li>
<li>n-LFSR序列由其结构常数和初态唯一确定</li>
<li>一个n-LFSR可以产生 个不同序列</li>
<li>一个n-LFSR的序列的最大周期是</li>
</ol>
<h3 id="LFSR的有理表示"><a href="#LFSR的有理表示" class="headerlink" title="LFSR的有理表示"></a>LFSR的有理表示</h3><p>$f(x)&#x3D;1+c_1x+c_2x^2+\dots + c_{n-1}x^{n-1}+c_nx^n$<br>$f(x)$中常数项$c_0 &#x3D; 1$<br>称为线性移位寄存器的联接多项式或生成多项式</p>
<p>$a(x)&#x3D;a_0+a_1x+a_2x^2\dots +a_{n-1}x^{n-1}+a_nx^n&#x3D;\sum a_nx^n$<br>$a(x)$称为序列的形式幂级数或生成函数</p>
<p>$a(x) &#x3D; \frac{g(x)}{f(x)}$</p>
<h3 id="g-x"><a href="#g-x" class="headerlink" title="g(x)"></a>g(x)</h3><p>n-LFSR有理表示中$g(x)$次数小于n<br>证明略<br>LFSR : g(x)的系数和结构常数与初态都有关系。<br>DSR ： g(x)的系数就是初态<br>求$g(x)$方法<br>根据初态，写出a(x)的前n项，次数最高为n-1 ，后<br>面的项不知道就用+⋯代替。a(x)与f(x)相乘后只取次数小<br>于等于n-1的项，即为g(x)。 这是因为：g(x)的最高次数为n-1，a(x)的n次以上的<br>项都会被抵消掉。</p>
<h1 id="m序列"><a href="#m序列" class="headerlink" title="m序列"></a>m序列</h1><h3 id="m序列以及其性质"><a href="#m序列以及其性质" class="headerlink" title="m序列以及其性质"></a>m序列以及其性质</h3><p>m序列周期为$2^n-1$，没有全0状态<br>定理-2：周期为p的序列的（非最简）有理表示为：<br>$a(x) &#x3D; \frac{a_0+a_1x+a_2x^2\dots +a_{p-1}x^{p-1}}{1+x^p}$<br>如果$p &#x3D; 2^n − 1$，则$a(x)$就是n阶寄存器产生的m序列</p>
<h3 id="本原多项式"><a href="#本原多项式" class="headerlink" title="本原多项式"></a>本原多项式</h3><p>定理-3：当$f (x)$为本原多项式，产生的序列 $a^~$为m序列<br>$gcd(a_0,a_1,\dots,a_n)&#x3D;1$则称$f(x)$是唯一分解整环$D$上本原多项式</p>
<ul>
<li>$f(x)$是既约的，即不能再分解因式</li>
<li>$f(x)$可以整除$x^m+1,m&#x3D;2^n-1$</li>
<li>$f(x)$不能整除$x^q+1,q&lt;m$</li>
</ul>
<h3 id="m序列的取样"><a href="#m序列的取样" class="headerlink" title="m序列的取样:"></a>m序列的取样:</h3><p>设 $\tilde{a} $ 是一个序列 $\tilde{a}&#x3D;{a_0,a_1,a_2,\dots ,a_n,\dots }$<br>$s$ 是一个正整数，令$\tilde{a^s}&#x3D; {a_0,a_s,a_{2s}\dots }$<br> 称 $\tilde{a^s}$为序列$\tilde{a}$ 的s采样<br>定理-4： 若 $\tilde{a}$ 是周期为p的m序列，$s &#x3D;s_1 mod p$<br>则$\tilde{a^s}&#x3D;\tilde{a^{s_1}}$</p>
<h3 id="m序列的伪随机性"><a href="#m序列的伪随机性" class="headerlink" title="m序列的伪随机性"></a>m序列的伪随机性</h3><h4 id="三个特性"><a href="#三个特性" class="headerlink" title="三个特性"></a>三个特性</h4><p>分布特性<br>$s&gt;1,Pr((\xi _1,\xi <em>2,\dots,\xi <em>s)&#x3D;(b_1,b_2,\dots ,b_s)) &#x3D; 1&#x2F;2^s$<br>相关特性<br>$\lim \frac{1}{s}\sum (-1)^{\xi <em>i}(-1)^{\xi <em>{i+\tau}}$<br>$&#x3D; 1,\tau &#x3D; 0; &#x3D; 0,\tau &gt;0$<br>游程特性<br>$𝑃𝑟(𝜉</em>{i+1} &#x3D; 𝜉 <em>{i+2}&#x3D; ⋯𝜉</em>{i+k} &#x3D; 0, 𝜉</em>{i+k+1} &#x3D; 1|𝜉_i &#x3D; 1) &#x3D; 1&#x2F;2^{k+1}$<br>$𝑃𝑟(𝜉</em>{i+1} &#x3D; 𝜉 <em>{i+2}&#x3D; ⋯𝜉</em>{i+k} &#x3D; 1, 𝜉</em>{i+k+1} &#x3D; 0|𝜉_i &#x3D; 0) &#x3D; 1&#x2F;2^{k+1}$</p>
<h4 id="m序列具有伪随机性"><a href="#m序列具有伪随机性" class="headerlink" title="m序列具有伪随机性"></a>m序列具有伪随机性</h4><p>定理-5：　设$a^{\infty}$是ｎ级二元ｍ序列，则<br>在一个周期中，0和1的出现次数分别为$2^{n-1}-1,2^{n-1}$<br>在一个周期中，游程总数为$2^{n-1}$<br> 对于任意的 $ 1\leq i &lt; n-2$<br> i 长的0游程和1游程都有$2^{n-i-2}$个<br> n-1长的0游程、n长的1游程各有一个；<br>证明方法：将游程数目转为状态数目</p>
<h1 id="DSR对偶移位寄存器"><a href="#DSR对偶移位寄存器" class="headerlink" title="DSR对偶移位寄存器"></a>DSR对偶移位寄存器</h1><p>(DSR: Dual Shift Registers)<br>LFSR： 也称 Fibonacci LFSRs<br>DSR： 也称 Galois LFSRs</p>
<h3 id="DSR的状态转换"><a href="#DSR的状态转换" class="headerlink" title="DSR的状态转换"></a>DSR的状态转换</h3><p>$x_1$是第1级寄存器中的值<br>新状态 $&#x3D; x_1$(结构常数) ⊕原状态左移一位后补零<br>若 $x_1 &#x3D; 0$，新状态 &#x3D; 原状态左移一位后补零；<br>若 $x_1 &#x3D; 1$，新状态 &#x3D;结构常数⊕原状态左移一位后补零。</p>
<h3 id="DSR特殊点"><a href="#DSR特殊点" class="headerlink" title="DSR特殊点"></a>DSR特殊点</h3><p>(1) 三个量(寄存器、结构常数和初态)的标记顺序一致；<br>(2) 反馈只有 $x_1$的值；<br>(3) DSR便于编程实现（反馈不必计算多个量的求和）;<br>(4) DSR的状态不是每一位都输出； (5) DSR与LFSR相同的有理表示产生相同序列；<br>(6) DSR的有理表示分别对应序列、结构常数和初态。</p>
<p>注意两者结构不同<br><img src="https://img2024.cnblogs.com/blog/3567579/202506/3567579-20250622104200257-1839927484.png" alt="image"></p>
<h3 id="DSR有理表示"><a href="#DSR有理表示" class="headerlink" title="DSR有理表示"></a>DSR有理表示</h3><p>$a(x)&#x3D;a_0+a_1x+a_2x^2\dots +a_{n-1}x^{n-1}+a_nx^n&#x3D;\sum a_nx^n$<br>$f(x)&#x3D;1+c_1x+c_2x^2+\dots + c_{n-1}x^{n-1}+c_nx^n$<br>$g(x)&#x3D;g_0+g_1x+g_2x^2+\dots + g_{n-1}x^{n-1}$<br>$g(x)$表示初态</p>
<h1 id="B-M算法"><a href="#B-M算法" class="headerlink" title="B-M算法"></a>B-M算法</h1><p>（Berlekamp–Massey）算法<br>迭代型求解序列生成多项式的算法<br>B-M 算法不需任何前提，求出产生序列段$a^N$的次数最低的联接多项式$𝑓_N(𝑥)$，即线性综合解<br>如果知道线性反馈移位寄存器的两个周期，2n长度的序列<br>就可以通过解方程组求得对应结构常数，得到生成多项式<br><img src="https://img2024.cnblogs.com/blog/3567579/202506/3567579-20250620165305765-1773487624.png" alt="image"></p>
<p>（注意，下面代码由AI生成，不保证正确）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">def berlekamp_massey(sequence):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Berlekamp-Massey 算法实现（二元域 GF(2)）</span><br><span class="line">    输入: sequence - 二进制序列 (0/1 列表)</span><br><span class="line">    输出: 生成多项式 f_n (系数列表), L_n (LFSR 长度)</span><br><span class="line">    并打印每一步的计算过程</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    N = len(sequence)</span><br><span class="line">    # 初始化变量</span><br><span class="line">    n = 0</span><br><span class="line">    f = [1]  # 初始多项式 f0(x) = 1 (系数列表: [常数项, x^1 系数, x^2 系数, ...])</span><br><span class="line">    L = 0    # 当前 LFSR 长度</span><br><span class="line">    # 存储历史更新点 (n, f_n, L_n, d_n)</span><br><span class="line">    history = []</span><br><span class="line">    </span><br><span class="line">    print(&quot;n\ta_n\td_n\tf_n(x)\t\tL_n\tm\tupdate type&quot;)</span><br><span class="line">    print(&quot;-&quot; * 70)</span><br><span class="line">    </span><br><span class="line">    while n &lt; N:</span><br><span class="line">        # 计算差异 d_n = a_n + Σ c_i * a_&#123;n-i&#125; (GF(2) 加法即 XOR)</span><br><span class="line">        d = sequence[n]  # 从 a_n 开始</span><br><span class="line">        # 计算反馈项 (c1*a_&#123;n-1&#125; + c2*a_&#123;n-2&#125; + ...)</span><br><span class="line">        # 只考虑当前L长度内的系数</span><br><span class="line">        for i in range(1, min(L + 1, len(f))):</span><br><span class="line">            if n - i &gt;= 0:  # 确保不越界</span><br><span class="line">                # GF(2) 乘法: AND, 加法: XOR</span><br><span class="line">                d ^= f[i] &amp; sequence[n - i]</span><br><span class="line">        </span><br><span class="line">        # 准备输出信息</span><br><span class="line">        f_str = &quot;1&quot;  # 常数项总是1</span><br><span class="line">        # 添加其他项</span><br><span class="line">        terms = []</span><br><span class="line">        for i in range(1, len(f)):</span><br><span class="line">            if f[i] == 1:</span><br><span class="line">                terms.append(f&quot;x^&#123;i&#125;&quot; if i &gt; 1 else &quot;x&quot;)</span><br><span class="line">        if terms:</span><br><span class="line">            f_str += &quot; + &quot; + &quot; + &quot;.join(terms)</span><br><span class="line">        </span><br><span class="line">        m_val = &quot;&quot;</span><br><span class="line">        update_type = &quot;no update&quot;</span><br><span class="line">        </span><br><span class="line">        if d != 0:  # 差异非零，需要更新多项式</span><br><span class="line">            if not history:  # 首次非零差异（没有历史点）</span><br><span class="line">                # 构造新多项式: 1 + x^&#123;n+1&#125;</span><br><span class="line">                f_next = [1] + [0] * n + [1]</span><br><span class="line">                L_next = n + 1</span><br><span class="line">                # 存储当前状态作为历史更新点</span><br><span class="line">                history.append((n, f.copy(), L, d))</span><br><span class="line">                update_type = &quot;first update&quot;</span><br><span class="line">                m_val = &quot;&quot;</span><br><span class="line">            else:</span><br><span class="line">                # 获取最近的历史点</span><br><span class="line">                m, f_m, L_m, d_m = history[-1]</span><br><span class="line">                m_val = str(m)</span><br><span class="line">                </span><br><span class="line">                # 计算位移量</span><br><span class="line">                shift = n - m</span><br><span class="line">                # 构造位移多项式: x^&#123;shift&#125; * f_m(x)</span><br><span class="line">                f_shifted = [0] * shift + f_m</span><br><span class="line">                </span><br><span class="line">                # 扩展多项式到相同长度</span><br><span class="line">                max_len = max(len(f), len(f_shifted))</span><br><span class="line">                f_padded = f + [0] * (max_len - len(f))</span><br><span class="line">                fs_padded = f_shifted + [0] * (max_len - len(f_shifted))</span><br><span class="line">                </span><br><span class="line">                # 计算新多项式: f_&#123;n+1&#125;(x) = f_n(x) + x^&#123;n-m&#125; f_m(x)</span><br><span class="line">                f_next = [a ^ b for a, b in zip(f_padded, fs_padded)]</span><br><span class="line">                </span><br><span class="line">                # 更新长度: L_&#123;n+1&#125; = max(L_n, n+1 - L_n)</span><br><span class="line">                L_next = max(L, n + 1 - L)</span><br><span class="line">                </span><br><span class="line">                # 如果长度增加，保存为新的历史点</span><br><span class="line">                if L_next &gt; L:</span><br><span class="line">                    history.append((n, f.copy(), L, d))</span><br><span class="line">                update_type = f&quot;update (m=&#123;m&#125;)&quot;</span><br><span class="line">        else:</span><br><span class="line">            # 差异为零，不更新多项式</span><br><span class="line">            f_next = f.copy()</span><br><span class="line">            L_next = L</span><br><span class="line">            update_type = &quot;d=0&quot;</span><br><span class="line">            m_val = &quot;&quot;</span><br><span class="line">        </span><br><span class="line">        # 输出当前步骤信息</span><br><span class="line">        print(f&quot;&#123;n&#125;\t&#123;sequence[n]&#125;\t&#123;d&#125;\t&#123;f_str:&lt;15&#125;\t&#123;L&#125;\t&#123;m_val&#125;\t&#123;update_type&#125;&quot;)</span><br><span class="line">        </span><br><span class="line">        # 更新变量</span><br><span class="line">        f = f_next</span><br><span class="line">        L = L_next</span><br><span class="line">        n += 1</span><br><span class="line">    </span><br><span class="line">    # 输出最终结果</span><br><span class="line">    print(&quot;\nFinal Result:&quot;)</span><br><span class="line">    f_str = &quot;1&quot;</span><br><span class="line">    terms = []</span><br><span class="line">    for i in range(1, len(f)):</span><br><span class="line">        if f[i] == 1:</span><br><span class="line">            terms.append(f&quot;x^&#123;i&#125;&quot; if i &gt; 1 else &quot;x&quot;)</span><br><span class="line">    if terms:</span><br><span class="line">        f_str += &quot; + &quot; + &quot; + &quot;.join(terms)</span><br><span class="line">    print(f&quot;Generating Polynomial: f(x) = &#123;f_str&#125;&quot;)</span><br><span class="line">    print(f&quot;LFSR Length: L = &#123;L&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">    # 返回多项式系数和长度</span><br><span class="line">    # 移除尾部多余的零</span><br><span class="line">    while len(f) &gt; 1 and f[-1] == 0:</span><br><span class="line">        f.pop()</span><br><span class="line">    return f, L</span><br></pre></td></tr></table></figure>
<p>已知： LFSR输出序列 $a_0a_1a_2⋯$，任意一位都是前面若干位的线性反馈值。<br>开始不知道寄存器的阶数和结构常数， BM算法逐次试验联接多项式，将f(x)从小次数到大次数逐渐增加进行尝试<br>BM算法更像是一个贪心算法（在对问题求解时，总是做出在当前看来是最好的选择），通过不断增加数来修改线性递推式，每次调整当前递推式时，保证新的递推式满足当前数列的次数最低的递推式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E5%AD%A6/" data-id="cmfajc26g0000hkf04j6dda9e" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-密码学：从艺术到科学" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E4%BB%8E%E8%89%BA%E6%9C%AF%E5%88%B0%E7%A7%91%E5%AD%A6/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T02:55:08.857Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="置换密码"><a href="#置换密码" class="headerlink" title="置换密码"></a>置换密码</h1><p>前置知识为置换群<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luminescence/p/18591274">https://www.cnblogs.com/luminescence/p/18591274</a><br>有限集合$S$上的一一对应映射<br>$p &#x3D; \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp;  \ 3 &amp; 1 &amp; 5 &amp; 4 &amp; 2 \end{pmatrix}$<br>简写为 $p &#x3D; (31542)$<br>逆置换 输出变输入，按列调整第一行为自然顺序<br>$p^{-1} &#x3D; (25143)$<br>对置换密码的攻击：穷举法，寻找有意义的排列</p>
<h1 id="代替密码"><a href="#代替密码" class="headerlink" title="代替密码"></a>代替密码</h1><h2 id="单表代替"><a href="#单表代替" class="headerlink" title="单表代替"></a>单表代替</h2><h3 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h3><p>将字符移动固定值，使用模运算实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encryptmessage</span>(<span class="params">message, shift = <span class="number">3</span></span>):</span><br><span class="line">    charset = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()-_=+[]&#123;&#125;|;:&#x27;,.&lt;&gt;?/&quot;</span></span><br><span class="line">    encrypted = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> message:</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> charset:</span><br><span class="line">            idx = charset.index(char)</span><br><span class="line">            new_idx = (idx + shift) % <span class="built_in">len</span>(charset)</span><br><span class="line">            encrypted += charset[new_idx]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            encrypted += char  <span class="comment"># 非字符集内的字符保持不变</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> encrypted</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decryptmessage</span>(<span class="params">encryptedmessage, shift = <span class="number">3</span></span>):</span><br><span class="line">    <span class="keyword">return</span> encryptmessage(encryptedmessage, -shift)</span><br></pre></td></tr></table></figure>
<h3 id="仿射变换密码"><a href="#仿射变换密码" class="headerlink" title="仿射变换密码"></a>仿射变换密码</h3><p>$X&#x3D;Y&#x3D;Z_q,k &#x3D; {(k_1,k_2)|k_1 \in Z_q,k_2 \in Z_q^<em>},m\in X, k &#x3D; (k_1,K_2)\in K$<br>$c &#x3D; E_k(m) &#x3D; (k_1 + k_2m)mod q$<br>$m &#x3D; k_2^{-1}(c-k_1)modq$<br>密钥量为$q\varphi (q)$<br>此处$k_2\in Z_q^</em>$ 参考密码学数学基础中关于群环域的知识<br>特别的<br>$k_2 &#x3D; 0$时称为加法密码，密钥量为$q$<br>$k_1 &#x3D; 0$时称为乘法密码，密钥量为$\varphi (q)$</p>
<h3 id="对单表代替密码的攻击"><a href="#对单表代替密码的攻击" class="headerlink" title="对单表代替密码的攻击"></a>对单表代替密码的攻击</h3><p>明密异同规律:英文字母的字母出现频率不同，而加密后不改变符号的频率特征<br>截获一定数量密文，统计各个字母出现频次<br>将出现频次高的密文字母，猜测为明文字母e,t,r等<br>根据字母组合、单词意义等信息进一步破解</p>
<h3 id="字典密码"><a href="#字典密码" class="headerlink" title="字典密码"></a>字典密码</h3><p>汉字进行加密</p>
<h2 id="多表代替"><a href="#多表代替" class="headerlink" title="多表代替"></a>多表代替</h2><p>多个明密文对照表</p>
<h3 id="viginere密码"><a href="#viginere密码" class="headerlink" title="viginere密码"></a>viginere密码</h3><p>$X^n &#x3D; Y^n &#x3D; Z^n, \quad m &#x3D; (m_1, m_2, \ldots, m_n) \in X^n$</p>
<p>$K &#x3D; \left{ \langle k_{11}, k_{21} \rangle, \langle k_{12}, k_{22} \rangle, \cdots, \langle k_{1n}, k_{2n} \rangle \right\rangle<br>\mid k_{ij} \in Z_q, k_{2i} \in Z_q^*, 1 \leq i \leq n },$</p>
<p>$k &#x3D; (\langle k_{11}, k_{21} \rangle, \langle k_{12}, k_{22} \rangle, \cdots, \langle k_{1n}, k_{2n} \rangle) \in K$</p>
<p>$c &#x3D; E_k(m) &#x3D; (k_{11} + k_{21}m_1, k_{12} + k_{22}m_2, \cdots, k_{1n} + k_{2n}m_n),$</p>
<p>运算都是模 $q$ 运算，密钥量 $q^{n}\varphi(q)^n$</p>
<h3 id="对多表密码的破解"><a href="#对多表密码的破解" class="headerlink" title="对多表密码的破解"></a>对多表密码的破解</h3><p><strong>重合指数</strong><br>$I_c(x) &#x3D; \frac{\sum_{i&#x3D;0}^{25} \binom{f_i}{2}}{\binom{n}{2}} &#x3D; \frac{\sum_{i&#x3D;0}^{25} f_i(f_i - 1)}{n(n-1)} \approx \sum_{i&#x3D;0}^{25} \left(\frac{f_i}{n}\right)^2$<br>$f_i$为字母 $i$ 在 $x$中出现的次数<br>有意义时：符合英文的字母出现频率<br>$I_c(x) &#x3D; 0.065$ 为单表代替<br>随机时：$I_c(x) &#x3D; 0.038$ 为多表代替<br>可以通过重合指数精确确定密钥长度<br>或者通过相同密文片段的距离最大公因子粗略确定密钥长度<br>#从艺术到科学<br>1949年，香农发表文章’Communication Theory of Secrecy Systems’标志着密码学的正式诞生</p>
<h3 id="One-Time-Pad"><a href="#One-Time-Pad" class="headerlink" title="One Time Pad"></a>One Time Pad</h3><p>一次一密是理论上的无条件安全的加密<br>1）密钥与明文一样长<br>2）密钥必须是真随机的<br>3）密钥只能对一个密文进行加密<br>但只具有理论价值，因为在实际中：<br> （1）难以做到密钥与明文一样长<br> （3）真随机的密钥难以实现<br> （4）每次更换密钥，效率太低<br>加密算法的安全分为两种<br>理论安全：不泄漏任何信息，不依赖敌手的计算能力。<br>计算安全：计算上困难的，依赖于敌手的计算能力。<br>可通过以下手段达到计算安全性：<br> 扩散(diffusion)：明文与密文的关系尽量混乱；<br> 混淆(confusion)：密钥与密文之间的关系尽量混乱。<br>实际中：<br> 置换（P盒）实现扩散；<br> 代替（S盒）实现混淆。<br> 二者乘积并多次迭代可达到足够的安全性<br>通过模仿一次一密，形成了序列密码（流密码）<br>通过扩散和混淆，形成了分组密码</p>
<p>进入现代密码学，加密不再局限于字母，而采用二进制串表示明密文，并采用计算机程序实现</p>
<p>密码学数学基础部分：<br>群环域：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luminescence/category/2434978.html">https://www.cnblogs.com/luminescence/category/2434978.html</a><br>初等数论：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/luminescence/category/2434979.html">https://www.cnblogs.com/luminescence/category/2434979.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E4%BB%8E%E8%89%BA%E6%9C%AF%E5%88%B0%E7%A7%91%E5%AD%A6/" data-id="cmfajc26u0003hkf0d2sh7qzs" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-我的第一篇博客" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T02:34:06.000Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>徘徊了这么久，终于走到这一步了<br>新的旅程终于开始<br>我也迎来了属于自己的<strong>破晓</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" data-id="cmfaij4bf0000ngf045s1cw9h" data-title="我的第一篇博客" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T02:26:31.607Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/hello-world/" data-id="cmfai7hib0000wcf09h4bft7t" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/08/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/08/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/08/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E5%AD%A6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/08/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%9A%E4%BB%8E%E8%89%BA%E6%9C%AF%E5%88%B0%E7%A7%91%E5%AD%A6/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>